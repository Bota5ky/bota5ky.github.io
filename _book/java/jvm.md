### 1. GC 评估指标

- **吞吐量：**程序的运行时间/(程序的运行时间+内存回收的时间)
- 垃圾收集开销：吞吐量的补数，垃圾收集器所占时间与总时间的比例。
- **暂停时间：** 执行垃圾收集时，程序的工作线程被暂停的时间。
- 收集频率：相对于应用程序的执行，收集操作发生的频率。
- 内存占用：Java 堆区所占的内存大小。
- 快速：一个对象从诞生到被回收所经历的时间。

吞吐量优先：单位时间内，STW 的时间最短
响应时间优先：尽可能让单次 STW 的时间最短

现在 JVM 调优标准：在最大吞吐量优先的情况下，降低停顿时间。

### 2. 各 GC 使用场景

|  垃圾收集器  |   分类   |   作用位置   |   使用算法   |     特点     |               适用场景               |
| :----------: | :------: | :----------: | :----------: | :----------: | :----------------------------------: |
|    Serial    |   串行   |    新生代    |   复制算法   | 响应速度优先 |    适用于单CPU环境下的client模式     |
|    ParNew    |   并行   |    新生代    |   复制算法   | 响应速度优先 |  多CPU环境Server模式下与CMS配合使用  |
|   Parallel   |   并行   |    新生代    |   复制算法   |  吞吐量优先  | 适用于后台运算而不需要太多交互的场景 |
|  Serial Old  |   串行   |    老年代    |   标记压缩   | 响应速度优先 |    适用于单CPU环境下的client模式     |
| Parallel Old |   并行   |    老年代    |   标记压缩   |  吞吐量优先  | 适用于后台运算而不需要太多交互的场景 |
|     CMS      |   并发   |    老年代    |   标记清除   | 响应速度优先 |        适用于互联网或B/S业务         |
|      G1      | 并发并行 | 新生代老年代 | 标记压缩复制 | 响应速度优先 |            面向服务端应用            |

### 3. JVM 常用参数

|        options         |                           参数含义                           |
| :--------------------: | :----------------------------------------------------------: |
|      -verbose:gc       |              输出GC日志信息，默认输出到标准输出              |
|      -XX:+PrintGC      |                输出GC日志。类似：-verbose:gc                 |
|  -XX:+PrintGCDetails   | 在发生垃圾回收时打印内存回收详细的日志并在进程退出时输出当前内存各区域分配情况 |
| -XX:+PrintGCTimeStamps |                     输出GC发生时的时间截                     |
| -XX:+PrintGCDateStamps | 输出GC发生时的时间戳（以日期的形式，如2013-05-04T21:53:59.234+0800) |
|   -XX:+PrintHeapAtGC   |                每一次GC前和GC后，都打印堆信息                |
|     -Xloggc:<file>     |    表示把GC日志写入到一个文件中去，而不是打印到标准输出中    |
|          -Xss          |                     设置每个线程的栈大小                     |

### 4. OOM 案例

栈空间溢出 StackOverFlow，一般也不称为 OOM。

- 堆溢出
- 元空间溢出
- GC overhead limit exceeded：垃圾回收效率不足，提前报异常
- 线程溢出：创建了大量线程

### 5. JVM 调优

JVM 监控及诊断工具

- 命令行：jps、jstat、jinfo、jmap、jstack

- GUI：Visual VM、eclipse MAT、Arthas

为什么要调优？

- 防止出现 OOM，进行 JVM 规划和预调优
- 解决程序运行中各种 OOM
- 减少 Full GC 出现的频率，解决运行慢、卡顿问题

### 5. 运行时数据区域

<center><img src="jvm.png" style="zoom:50%"></center>

- **虚拟机栈：**Java 虚拟机栈是线程私有的数据区，Java 虚拟机栈的生命周期与线程相同，虚拟机栈也是局部变量的存储位置。方法在执行过程中，会在虚拟机栈种创建一个 **栈帧（stack frame）**
- **本地方法栈：**本地方法栈也是线程私有的数据区，本地方法栈存储的区域主要是 Java 中使用 `native` 关键字修饰的方法所存储的区域
- **程序计数器：**程序计数器也是线程私有的数据区，这部分区域用于存储线程的指令地址，用于判断线程的分支、循环、跳转、异常、线程切换和恢复等功能，这些都通过程序计数器来完成
- **方法区：**方法区是各个线程共享的内存区域，它用于存储虚拟机加载的**类信息**、**常量**、**静态变量**、**即时编译器编译后的代码**等数据
- **堆：**堆是线程共享的数据区，堆是 JVM 中最大的一块存储区域，所有的对象实例都会分配在堆上
- **运行时常量池：**运行时常量池又被称为 `Runtime Constant Pool`，这块区域是方法区的一部分，它的名字非常有意思，它并不要求常量一定只有在编译期才能产生，也就是并非编译期间将常量放在常量池中，运行期间也可以将新的常量放入常量池中，String 的 `intern()` 方法就是一个典型的例子

### 6. 垃圾回收

可作为 gc roots 的对象：

- **虚拟机栈**中引用的对象
- 方法区中**静态属性**引用的对象
- 方法区中**常量**引用的对象
- **本地方法栈**中JNI引用的对象

### 7. HotSpot 垃圾分代回收算法

默认情况下新生代占 1/3，老年代占 2/3

绝大多数对象在新生代中被创建，这里的垃圾回收非常频繁且速度很快

新生代通常采用复制算法，由于存活对象少，复制成本很低

新生代分为 Eden、Surivivor  from、Surivivor to 区，占比 8:1:1

Eden 填满后触发一次新生代的垃圾回收，称为 minor gc，存活对象复制到任一 Surivivor 区，然后将 Eden 区清空即可完成这次 gc，Surivivor from 区的存活对象会复制到另一个 Surivivor to 区，这里需要保证 to 区为空

- 存活超过复制次数阈值（默认 15）会被复制到老年代

- Surivivor 空间不够容纳存活对象时，也会直接进入老年代
- 大数组或者特别大的字符串

老年代通常使用标记整理算法进行回收，将存活对象向一端进行移动，称为 major gc

### 8. G1/CMS 并发标记原理

三色标记：
- 白色：没有被访问过 -> 垃圾对象
- 黑色：包括其引用都被访问过
- 灰色：被访问过，但还存在一些引用没有被访问

**对象消失问题**：扫描过程中插入了一条或多条从黑色对象到白色对象的新引用，并且同时去掉了灰色对象到该白色对象的直接引用或者间接引用。

解决方法，破坏上述两个条件之一即可：

- 增量更新：记录引用关系，并发扫描结束后根据记录重新扫描一次 -> CMS

- 原始快照（SATB）：记录 -> G1

[JVM_垃圾收集之三色标记算法详解](https://blog.csdn.net/chuige2013/article/details/129659171)

CMS 缺点：占用 CPU 资源，不超过 25%；浮动垃圾；内存碎片

### 9. 其他垃圾回收算法

Serial：JDK 1.3 版本之前唯一的串行垃圾回收器，Stop The World

ParNew：多线程垃圾回收，只负责新生代的垃圾回收，可以配合 Serial Old 和 Concurrent Mark Swap 处理老年代

Parallel Scavenge：也是新生代的收集器，可控制吞吐量，gc 自适应，配合 Parallel old 处理老年代

### 10. 类加载机制

类的生命周期：（class 文件 -> Java虚拟机内存 -> 卸载）

- 加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

类的加载过程：

- 加载：查找并加载类的二进制数据（Class文件）
  - 方法区：类的类信息
  - 堆：Class 文件对应的类实例
- 验证：确保加载的类信息是正确的
- 准备：为类的静态变量进行初始化，分配空间并赋予初始值。例如：`public static int a = 1;` 在准备阶段对静态变量 a 赋默认值 0
- 解析：是将符号应用转换为直接引用
- 初始化：JVM 对类进行初始化，对静态变量赋予正确值。例如：`public static int a = 1;`这个时候才对静态变量 a 赋初始值 1
  - 静态代码块

### 11. String

String 代表的是 Java 中的字符串 ， String 类比较特殊，它整个类都是被 final 修饰的，也就是说，String 不能被任何类继承，任何修改 String 字符串的⽅法都是创建了⼀个新的字符串（保证了线程安全性）。

不可变对象不是真的不可变，可以通过**反射**来对其内部的属性和值进⾏修改，不过⼀般我们不这样做。  

方法`String.intern()`：在 jdk1.7 及以后调⽤`intern()`⽅法是判断运⾏时常量池中是否有指定的字符串，如果没有的话，就把字符串添加到常量池（jdk1.8 之后，字符串常量池在堆中）中，并返回常量池中的对象。  

```java
String a = new String("ab");
String b = new String("ab");
String c = "ab";
String d = "a";
String e = new String("b");
String f = d + e; // + 号相当于是执行 new StringBuilder.append(), 但每次都会new StringBuilder()，所以多次拼接建议自建 StringBuilder
String g = "a" + "b"; // 编译器会优化，会直接被优化为bbbccc，也就是直接创建了一个 bbbccc 对象

System.out.println(a.intern() == b);          //false
System.out.println(a.intern() == b.intern()); //true
System.out.println(a.intern() == c);          //true
System.out.println(a.intern() == f);	      //false
//equals()方法作对比都是true
```

