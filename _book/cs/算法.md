### 1. 排序算法

### 2. LRU (Least Recently Used) 最近最少使用

JDK自带实现，继承`LinkedHashMap`，重写`removeEldestEntry`方法

```java
class LRUCache extends LinkedHashMap<Integer, Integer> {
    //构造器等实现

    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity;
    }
}
```

对应力扣题 146. LRU 缓存，采用双向链表实现

### 3. LFU (Least Frequently Used) 最不经常使用

对应力扣题 460. LFU 缓存，采用多条双向链表实现

```java
class LFUCache {
    private final DoubleLinkedList tailList;
    private final Map<Integer, Node> cache;
    private final int capacity;

    private static class DoubleLinkedList {
        int frequency;
        Node head;
        Node tail;
        DoubleLinkedList moreFreq;
        DoubleLinkedList lessFreq;

        DoubleLinkedList(int frequency) {
            //只保留了基本的数据结构
        }
    }

    private static class Node {
        int key;
        int val;
        Node pre;
        Node next;
        DoubleLinkedList doubleLinkedList;
    }
}
```

### 4. KMP 算法

`next[j-1]`代表子串可以“跳过匹配”的字符个数，参考教程 [BV1AY4y157yL](https://www.bilibili.com/video/BV1AY4y157yL/)

| 子串 |  A   |  B   |  A   |  C   |  A   |  B   |  A   |  B   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| next |  0   |  0   |  1   |  0   |  1   |  2   |  3   |  2   |

```java
var next = new int[pattern.length()];
for (int i = 1, j = 0; i < pattern.length(); i++) {
    while (j > 0 && pattern.charAt(i) != pattern.charAt(j)) {
        j = next[j - 1];
    }
    if (pattern.charAt(i) == pattern.charAt(j)) {
        j++;
    }
    next[i] = j;
}
```

遍历时能保证`i`一直增加

### 5. 位运算

#### 5.1 绝对值

```java
mask = num >> (num.bit_length() - 1)  # 获取符号位，正数为0，负数为-1
(num + mask) ^ mask  # 使用异或运算去除符号位

(num ^ (num >> 31)) - (num >> 31) # 另一种写法
```

`num`为正数时，`mask`等于0，`num + mask`不变，`(num + mask) ^ mask`等于`num`

`num`为负数时，`mask`等于-1，`num + mask`为负数再减1，`(num + mask) ^ mask`，因为负数异或-1，结果为负数的绝对值减1

#### 5.2 数字交换

```java
a = a^b
b = a^b
a = a^b
```
