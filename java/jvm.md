### 1. 运行时数据区域

<center><img src="jvm.png" style="zoom:50%"></center>

- **虚拟机栈：**Java 虚拟机栈是线程私有的数据区，Java 虚拟机栈的生命周期与线程相同，虚拟机栈也是局部变量的存储位置。方法在执行过程中，会在虚拟机栈种创建一个 **栈帧（stack frame）**
- **本地方法栈：**本地方法栈也是线程私有的数据区，本地方法栈存储的区域主要是 Java 中使用 `native` 关键字修饰的方法所存储的区域
- **程序计数器：**程序计数器也是线程私有的数据区，这部分区域用于存储线程的指令地址，用于判断线程的分支、循环、跳转、异常、线程切换和恢复等功能，这些都通过程序计数器来完成
- **方法区：**方法区是各个线程共享的内存区域，它用于存储虚拟机加载的**类信息**、**常量**、**静态变量**、**即时编译器编译后的代码**等数据
- **堆：**堆是线程共享的数据区，堆是 JVM 中最大的一块存储区域，所有的对象实例都会分配在堆上
- **运行时常量池：**运行时常量池又被称为 `Runtime Constant Pool`，这块区域是方法区的一部分，它的名字非常有意思，它并不要求常量一定只有在编译期才能产生，也就是并非编译期间将常量放在常量池中，运行期间也可以将新的常量放入常量池中，String 的 `intern()` 方法就是一个典型的例子

### 2. 垃圾回收

可作为 gc roots 的对象：

- **虚拟机栈**中引用的对象
- 方法区中**静态属性**引用的对象
- 方法区中**常量**引用的对象
- **本地方法栈**中JNI引用的对象

JDK 1.2 之后对引用进行了扩充：

- 强引用：不会被回收
- 软引用：内存要溢出的时候会回收
- 弱引用：只要发生垃圾回收，就会被回收
- 虚引用：在回收时会收到一个通知

### 3. JVM 有哪些垃圾回收算法？

- 标记清除算法:
  - 标记阶段：把垃圾内存标记出来
  - 清除阶段: 直接将垃圾内存回收
  - 这种算法是比较简单的，但是有个很严重的问题，就是会产生大量的内存碎片
- 复制算法：为了解决标记清除算法的内存碎片问题，就产生了复制算法，复制算法将内存分为大小相等的两半，每次只使用其中一半。垃圾回收时，将当前这一块的存活对象全部拷贝到另一半，然后当前这一半内存就可以直接清除。这种算法没有内存碎片，但是他的问题就在于浪费空间。而且，他的效率跟存活对象的个数有关。
- 标记压缩算法：为了解决复制算法的缺陷，就提出了标记压缩算法。这种算法在标记阶段跟标记清除算法是一样的，但是在完成标记之后，不是直接清理垃圾内存，而是将存活对象往一端移动，然后将边界以外的所有内存直接清除。

### 4. HotSpot 垃圾分代回收算法

默认情况下新生代占 1/3，老年代占 2/3

绝大多数对象在新生代中被创建，这里的垃圾回收非常频繁且速度很快

新生代通常采用复制算法，由于存活对象少，复制成本很低

新生代分为 Eden、Surivivor  from、Surivivor to 区，占比 8:1:1

Eden 填满后触发一次新生代的垃圾回收，称为 minor gc，存活对象复制到任一 Surivivor 区，然后将 Eden 区清空即可完成这次 gc，Surivivor from 区的存活对象会复制到另一个 Surivivor to 区，这里需要保证 to 区为空

- 存活超过复制次数阈值（默认 15）会被复制到老年代

- Surivivor 空间不够容纳存活对象时，也会直接进入老年代
- 大数组或者特别大的字符串

老年代通常使用标记整理算法进行回收，将存活对象向一端进行移动，称为 major gc

### 5. G1/CMS 并发标记原理

三色标记：
- 白色：没有被访问过 -> 垃圾对象
- 黑色：包括其引用都被访问过
- 灰色：被访问过，但还存在一些引用没有被访问

**对象消失问题**：扫描过程中插入了一条或多条从黑色对象到白色对象的新引用，并且同时去掉了灰色对象到该白色对象的直接引用或者间接引用。

解决方法，破坏上述两个条件之一即可：

- 增量更新：记录引用关系，并发扫描结束后根据记录重新扫描一次 -> CMS

- 原始快照（SATB）：记录 -> G1

[JVM_垃圾收集之三色标记算法详解](https://blog.csdn.net/chuige2013/article/details/129659171)

CMS 缺点：占用 CPU 资源，不超过 25%；浮动垃圾；内存碎片

### 6. 其他垃圾回收算法

Serial：JDK 1.3 版本之前唯一的串行垃圾回收器，Stop The World

ParNew：多线程垃圾回收，只负责新生代的垃圾回收，可以配合 Serial Old 和 Concurrent Mark Swap 处理老年代

Parallel Scavenge：也是新生代的收集器，可控制吞吐量，gc 自适应，配合 Parallel old 处理老年代

### 7. 类加载机制

类的生命周期：（class 文件 -> Java虚拟机内存 -> 卸载）

- 加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

类的加载过程：

- 加载：查找并加载类的二进制数据（Class文件）
  - 方法区：类的类信息
  - 堆：Class 文件对应的类实例
- 验证：确保加载的类信息是正确的
- 准备：为类的静态变量进行初始化，分配空间并赋予初始值。例如：`public static int a = 1;` 在准备阶段对静态变量 a 赋默认值 0
- 解析：是将符号应用转换为直接引用
- 初始化：JVM 对类进行初始化，对静态变量赋予正确值。例如：`public static int a = 1;`这个时候才对静态变量 a 赋初始值 1
  - 静态代码块

JDK 自带有三个类加载器：

- BootStrapClasserLoader 是 ExtClassLoader 的父类加载器，是由 C 语言实现，加载`%JAVA_HOME%/lib`下的 jar 包和 class 文件
- ExtClassLoader 是 AppClassLoader 的父类加载器，负责加载`%JAVA_HOME%/lib/ext`下的 jar 包和 class 文件
- AppClassLoader 是自定义加载器的父类，负责加载`classpath`下的类文件
- 用户自定义类加载器 可以用流、文件、数据库、网络形式加载

### 8. String

String 代表的是 Java 中的字符串 ， String 类比较特殊，它整个类都是被 final 修饰的，也就是说，String 不能被任何类继承，任何修改 String 字符串的⽅法都是创建了⼀个新的字符串（保证了线程安全性）。

不可变对象不是真的不可变，可以通过**反射**来对其内部的属性和值进⾏修改，不过⼀般我们不这样做。  

方法`String.intern()`：在 JDK 1.7 及以后调⽤ intern() ⽅法是判断运⾏时常量池中是否有指定的字符串，如果没有的话，就把字符串添加到常量池（JDK 8 之后，字符串常量池在堆中）中，并返回常量池中的对象。  

```java
String a = new String("ab");
String b = new String("ab");
String c = "ab";
String d = "a";
String e = new String("b");
String f = d + e; // + 号相当于是执行 new StringBuilder.append(), 但每次都会new StringBuilder()，所以多次拼接建议自建 StringBuilder
String g = "a" + "b"; // 编译器会优化，会直接被优化为bbbccc，也就是直接创建了一个 bbbccc 对象

System.out.println(a.intern() == b);          //false
System.out.println(a.intern() == b.intern()); //true
System.out.println(a.intern() == c);          //true
System.out.println(a.intern() == f);	      //false
//equals()方法作对比都是true
```

### GC评估指标
- 吞吐量：程序的运行时间/(程序的运行时间+内存回收的时间)
- 垃圾收集开销：吞吐量的补数，垃圾收集器所占时间与总时间的比例。
- 暂停时间: 执行垃圾收集时，程序的工作线程被暂停的时间。
- 收集频率：相对于应用程序的执行，收集操作发生的频率。
- 内存占用：Java 堆区所占的内存大小。
- 快速：一个对象从诞生到被回收所经历的时间。

吞吐量优先：单位时间内，STW 的时间最短
响应时间优先：尽可能让单次 STW 的时间最短