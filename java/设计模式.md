### 1. 懒汉式

懒汉式单例模式在第一次调用的时候进行实例化。

#### 1.1 适用于单线程环境（不推荐）

此方式在单线程的时候工作正常，但在多线程的情况下就有问题了。如果两个线程同时运行到判断instance是否为null的if语句，并且instance的确没有被创建时，那么两个线程都会创建一个实例，此时类型Singleton就不再满足单例模式的要求了。

```java
public class Singleton {
	private static Singleton instance = null;
  
	private Singleton() {}
  
	public static Singleton getInstance() {
		if (null == instance) {
			instance = new Singleton();
		}
		return instance;
	}
}
```

#### 1.2 适用于多线程环境，但效率不高（不推荐）

为了保证在多线程环境下我们还是只能得到该类的一个实例，只需要在getInstance()方法加上同步关键字sychronized，就可以了。但每次调用getInstance()方法时都被synchronized关键字锁住了，会引起线程阻塞，影响程序的性能。

```java
public static synchronized Singleton getInstance() {
	if (instance == null) {
		instance = new Singleton();
	}
	return instance;
}
```

#### 1.3 双重检验锁

为了在多线程环境下，不影响程序的性能，不让线程每次调用`getInstance()`方法时都加锁，而只是在实例未被创建时再加锁，在加锁处理里面还需要判断一次实例是否已存在。

```java
public static Singleton getInstance() {
	// 先判断实例是否存在，若不存在再对类对象进行加锁处理
	if (instance == null) {
		synchronized (Singleton.class) {
			if (instance == null) {
				instance = new Singleton();
			}
		}
	}
	return instance;
}
```

#### 1.4 静态内部类方式（推荐）

加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。 由于在调用`StaticSingleton.getInstance()`的时候，才会对单例进行初始化，而且通过反射，是不能从外部类获取内部类的属性的；由于静态内部类的特性，只有在其被第一次引用的时候才会被加载，所以可以保证其线程安全性。
总结：

- 优势：兼顾了懒汉模式的内存优化（使用时才初始化）以及饿汉模式的安全性（不会被反射入侵）
- 劣势：需要两个类去做到这一点，虽然不会创建静态内部类的对象，但是其 Class 对象还是会被创建，而且是属于永久带的对象

```java
public class StaticSingleton {
	private StaticSingleton() {}
  
	// 获取实例
	public static StaticSingleton getInstance() {
		return StaticSingletonHolder.instance;
	}

	// 一个私有的静态内部类，用于初始化一个静态final实例
	private static class StaticSingletonHolder {
		private static final StaticSingleton instance = new StaticSingleton();
	}

	public void methodA() {}

	public void methodB() {}

	public static void main(String[] args) {
		StaticSingleton.getInstance().methodA();
		StaticSingleton.getInstance().methodB();
	}
}
```

### 2. 饿汉式

饿汉式单例类：在类初始化时，已经自行实例化。

#### 2.1 饿汉式

```java
public class Singleton {
	private static final Singleton instance = new Singleton();

	private Singleton() {}

	public static Singleton getInstance() {
		return instance;
	}
}
```

#### 2.2 枚举方式（推荐）

创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量）。

```java
public class Singleton {
	public static void main(String[] args) {
		Single single = Single.SINGLE;
		single.print();
	}

	enum Single {
		SINGLE;

		private Single() {}

		public void print() {
			System.out.println("hello world");
		}
	}
}
```

### 2. 设计原则

#### 2.1 SOLID原则是面向对象设计和编程中的一组基本原则，其中SOLID分别是以下五个原则的首字母缩写：

- 单一职责原则(Single Responsibility Principle，SRP)。一个类或者模块只应该有一个单一的责任。这个原则告诉我们，一个类应该只负责一项功能，不要试图把太多的职责塞到一个类里面。

- 开闭原则(Open Closed Principle，OCP)。软件应该对扩展开放，对修改关闭。这个原则告诉我们，我们应该尽量通过扩展来实现新的功能，而不是去修改已经存在的代码。

- 里氏替换原则(Liskov Substitution Principle，LSP)。子类可以被看作是父类的一种类型，即父类能出现的地方子类也能够出现。这个原则告诉我们，在使用继承时，子类不能改变父类原有的行为，否则会导致程序出现意想不到的问题。

- 接口隔离原则(Interface Segregation Principle，ISP)。客户端不应该依赖于它不需要的接口。这个原则告诉我们，在设计接口时，应该尽量将接口拆分成更小粒度的接口，避免接口的臃肿和复杂度的增加。

- 依赖倒置原则(Dependency Inversion Principle，DIP)。高层模块不应该依赖低层模块，二者都应该依赖其抽象。这个原则告诉我们，在设计类和模块之间的关系时，应该通过抽象来实现低耦合、高内聚的设计。

#### 2.2 开闭原则

开闭原则是指软件设计中的一个基本原则，它强调"软件实体（类、模块、函数等）应该对扩展开放，对修改关闭"。换言之，开闭原则要求我们在设计软件时，应该尽量避免直接修改已有的代码，而是通过添加新的代码来扩展功能，从而使系统更加稳定和灵活。

这个原则的核心思想就是面向对象设计的继承和多态特性，即通过继承来扩展原有的功能，而不是直接修改原有的代码。同时，通过多态可以将具体的实现与抽象的接口分离开来，从而降低了代码的耦合度，提高了代码的可维护性和可扩展性。

总之，遵循开闭原则可以使软件系统具有更好的可维护性、可扩展性和可复用性，从而降低软件开发的成本和风险。

#### 2.3 里氏替换原则

里氏替换原则是面向对象设计中的重要原则之一，它指出：任何一个基类可以出现的地方，子类一定可以出现。也就是说，子类可以完全替代父类并且不会影响程序的正确性。

这个原则的意义在于保证代码的可维护性、可扩展性和可复用性。如果不遵循里氏替换原则，可能会导致程序的耦合度过高，增加了后期维护的难度，并且给系统带来了潜在风险。

具体而言，里氏替换原则需要满足以下条件：

- 子类必须完全实现父类的抽象方法。

- 子类可以有自己的方法，但不能覆盖父类的非抽象方法。

- 子类的前置条件必须弱于父类；子类的后置条件必须强于父类。

- 子类不能抛出比父类更多或更宽泛的异常。

总之，里氏替换原则是一种优秀的编程习惯，它可以帮助我们编写出高质量、可维护的代码，提高程序的灵活性和可复用性。

#### 2.4 接口隔离原则

接口隔离原则（Interface Segregation Principle，ISP）是面向对象设计中的一项原则，指的是客户端不应该依赖于它不需要的接口。简而言之，一个接口应该只包含客户端需要的方法，而不应该强迫客户端实现它们不需要的方法。

这个原则的目标是减少系统的耦合性，提高系统的可维护性、可扩展性和可重用性。如果一个接口包含了过多的方法，那么实现这个接口的类就会出现“胖接口”的问题，这样会导致代码的臃肿和复杂度的增加，影响程序的可读性、可维护性和可测试性。

因此，按照接口隔离原则，我们应该将一个大接口拆分成多个小接口，每个小接口提供一组相关的方法，客户端只需要实现自己需要的接口即可。这样可以降低实现的难度，减少出错的可能性，同时也方便后期对系统的维护和修改。

#### 2.5 依赖倒置原则

依赖倒置原则（Dependence Inversion Principle，DIP）是指设计代码结构时，高层模块不应该依赖低层模块，二者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖抽象。这个原则是面向对象设计中很重要的一条原则之一，它有助于降低代码的耦合性和提高代码的灵活性、可读性和可扩展性。