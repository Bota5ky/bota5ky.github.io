### 1. 设计原则

**SOLID 原则：**是面向对象设计和编程中的一组基本原则，由以下五个原则的首字母缩写组成：

- 单一职责原则（Single Responsibility Principle, SRP）：一个类或者模块只应该有一个单一的责任。这个原则告诉我们，一个类应该只负责一项功能，不要试图把太多的职责塞到一个类里面。

- 开闭原则（Open Closed Principle, OCP）：软件应该对扩展开放，对修改关闭。这个原则告诉我们，我们应该尽量通过扩展来实现新的功能，而不是去修改已经存在的代码。

- 里氏替换原则（Liskov Substitution Principle, LSP）：子类可以被看作是父类的一种类型，即父类能出现的地方子类也能够出现。这个原则告诉我们，在使用继承时，子类不能改变父类原有的行为，否则会导致程序出现意想不到的问题。

- 接口隔离原则（Interface Segregation Principle, ISP）：客户端不应该依赖于它不需要的接口。这个原则告诉我们，在设计接口时，应该尽量将接口拆分成更小粒度的接口，避免接口的臃肿和复杂度的增加。

- 依赖倒置原则（Dependency Inversion Principle, DIP）：高层模块不应该依赖低层模块，二者都应该依赖其抽象。这个原则告诉我们，在设计类和模块之间的关系时，应该通过抽象来实现低耦合、高内聚的设计。

### 2. 单例模式

懒汉式单例模式在第一次调用的时候进行实例化。

**适用于单线程环境（不推荐）：**

此方式在单线程的时候工作正常，但在多线程的情况下就有问题了。如果两个线程同时运行到判断instance是否为null的if语句，并且instance的确没有被创建时，那么两个线程都会创建一个实例，此时类型Singleton就不再满足单例模式的要求了。

```java
public class Singleton {
	private static Singleton instance = null;
  
	private Singleton() {}
  
	public static Singleton getInstance() {
		if (null == instance) {
			instance = new Singleton();
		}
		return instance;
	}
}
```

**适用于多线程环境，但效率不高（不推荐）:**

为了保证在多线程环境下我们还是只能得到该类的一个实例，只需要在getInstance()方法加上同步关键字sychronized，就可以了。但每次调用getInstance()方法时都被synchronized关键字锁住了，会引起线程阻塞，影响程序的性能。

```java
public static synchronized Singleton getInstance() {
	if (instance == null) {
		instance = new Singleton();
	}
	return instance;
}
```

**双重检验锁（DCL，即 double-checked locking）：**

为了在多线程环境下，不影响程序的性能，不让线程每次调用`getInstance()`方法时都加锁，而只是在实例未被创建时再加锁，在加锁处理里面还需要判断一次实例是否已存在。

```java
private static volatile Singleton instance = null;

public static Singleton getInstance() {
	// 先判断实例是否存在，若不存在再对类对象进行加锁处理
	if (instance == null) {
		synchronized (Singleton.class) {
			if (instance == null) {
				instance = new Singleton();
			}
		}
	}
	return instance;
}
```

如果 instance 属性不加 volatile，可能会返回未初始化完成的对象。

**静态内部类方式（推荐）：**

加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。 由于在调用`StaticSingleton.getInstance()`的时候，才会对单例进行初始化，而且通过反射，是不能从外部类获取内部类的属性的；由于静态内部类的特性，只有在其被第一次引用的时候才会被加载，所以可以保证其线程安全性。
总结：

- 优势：兼顾了懒汉模式的内存优化（使用时才初始化）以及饿汉模式的安全性（不会被反射入侵）
- 劣势：需要两个类去做到这一点，虽然不会创建静态内部类的对象，但是其 Class 对象还是会被创建，而且是属于永久带的对象

```java
public class StaticSingleton {
	private StaticSingleton() {}
	// 这里可以去掉synchronized，因为JVM会保证静态内部类的加载是线程安全
	public static StaticSingleton getInstance() {
		return StaticSingletonHolder.instance;
	}

	// 一个私有的静态内部类，用于初始化一个静态final实例
	private static class StaticSingletonHolder {
		private static final StaticSingleton instance = new StaticSingleton();
	}
}
```

饿汉式单例类：在类初始化时，已经自行实例化。

**饿汉式：**

```java
public class Singleton {
	private static final Singleton instance = new Singleton();

	private Singleton() {}

	public static Singleton getInstance() {
		return instance;
	}
}
```

**枚举方式（推荐）：**

创建枚举默认就是线程安全的，所以不需要担心 DCL，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不能通过 reflection attack 来调用私有构造方法。

```java
public class Singleton {
	public static void main(String[] args) {
		Single single = Single.SINGLE;
		single.print();
	}

	enum Single {
		SINGLE;

		private Single() {}

		public void print() {
			System.out.println("hello world");
		}
	}
}
```

### 3. 

