### 1. JDK、JRE、JVM的区别

JDK - Java Development Kit（Java开发工具包）包括：

- 开发工具
  - 基本类库
  - javac 编译
  - javap 反编译
  - javadoc
- 运行环境 JRE（Java Runtime Environment）
  - JVM（Java Virtual Mechinal）不同操作系统的机器指令是有可能不一样的，所以就导致不同操作系统上的 JVM 是不一样的。凡是编译后是 Java 字节码的都可以在 JVM 上运行，如 Apache Groovy、Scala、Kotlin 等等。
  - JVM 工作所需要的类库

### 2. Integer 缓存池

它的默认值⽤于缓存 -128 - 127 之间的数字，如果有 -128 - 127 之间的数字的话，使⽤ new Integer 不⽤创建对象，会直接从缓存池中取，此操作会减少堆中对象的分配，有利于提⾼程序的运⾏效率。例如创建⼀个 Integer a = 24，其实是调⽤ Integer 的 valueOf 方法。

### 3. UTF-8 和 Unicode 的关系  

- Unicode 是一个标准字符集，旨在包含世界上所有的字符、符号和标点符号，无论是用于现代语言、历史文献、数学符号、特殊符号等。Unicode 定义了每个字符一个唯一的代码点（code point），通常用十六进制数表示。这种编码允许计算机在不同系统和应用中共享和交换文本，无论它们使用的是哪种语言或字符。
- UTF-8 是 Unicode 字符编码的一种具体实现方式。它是一种变长的字符编码方式，可以使用1至4个字节来表示不同的 Unicode 字符。UTF-8 的设计允许它在表示拉丁字母等常见字符时保持与 ASCII 编码的兼容性，同时能和 UTF-32 ⼀样，也能够表示全球范围内的字符，⼜能有效减少存储传输过程中占⽤的空间。UTF-8 编码的特点是，对于英文和其他大部分常见字符，只使用一个字节，而对于较不常见的字符，使用更多的字节。

```
U+ 0000 ~ U+ 007F: 0XXXXXXX
U+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXX
U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX
U+10000 ~ U+1FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
```

char 类型在 Java 中是 2 个字节，Java 采用 Unicode，2个字节表示一个字符。所以`char = '中'`合法。

### 4. 类加载机制

类的生命周期：（class 文件 -> Java虚拟机内存 -> 卸载）

- 加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

类的加载过程：

- 加载：查找并加载类的二进制数据（Class文件）
  - 方法区：类的类信息
  - 堆：Class 文件对应的类实例
- 验证：确保加载的类信息是正确的
- 准备：为类的静态变量进行初始化，分配空间并赋予初始值。例如：`public static int a = 1;` 在准备阶段对静态变量 a 赋默认值 0
- 解析：是将符号应用转换为直接引用
- 初始化：JVM 对类进行初始化，对静态变量赋予正确值。例如：`public static int a = 1;`这个时候才对静态变量 a 赋初始值 1
  - 静态代码块

JDK 自带有三个类加载器：

- BootStrapClasserLoader 是 ExtClassLoader 的父类加载器，是由 C 语言实现，加载`%JAVA_HOME%/lib`下的 jar 包和 class 文件
- ExtClassLoader 是 AppClassLoader 的父类加载器，负责加载`%JAVA_HOME%/lib/ext`下的 jar 包和 class 文件
- AppClassLoader 是自定义加载器的父类，负责加载`classpath`下的类文件
- 用户自定义类加载器 可以用流、文件、数据库、网络形式加载

### 5. 双亲委派模型

当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。（这样就保证了我们不能篡改 java.己有的类）

### 6. 异常

**参考文献：[看完这篇 Exception 和 Error，和面试官扯皮就没问题了](https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&mid=2247495984&idx=1&sn=97c90237ae80d1a244bd34edf2628986&source=41#wechat_redirect)**

Java 中的所有异常都来自顶级父类 Throwable（实现 Serializable 接口）。

Throwable下有两个子类Exception和Error。

- Eror表示非常严重的措误，比 StakOverFlowError 和 0ut0fMemoryError，通常这些误出现时，仅仅想靠程序自己是解决不了的，可能是虚拟机、磁盘、操作系统层面出现的问题了，所以通常也不建议在代码中去捕获这些Eror，因为捕获的意义不大，因为程序可能已经根本运行不了了。
- Exception表示异常，表示程序出现 Exception时，是可以靠程序自己来解决的，比 NullPointerException、 IllealAcessException等，我们可以捕获这些异常来做特殊处理。Exception的子类通常又可以分为RuntimeException和非RuntimeException两类。
  - RuntimeException 表示运行期异常（又称 uncheckedException），表示这个异常是在代码运行过程中抛出的，这些异常是非检查异常，程序中可以选泽浦获处理，也可以不处理，这些导一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生，比如 NullPointerException、IndexOutOfBoundsException 等
  - 非RuntimeException表示非运行期异常，也就是我们常说检查异常，是必须进行处的异常，如果不处理，程序就不能检查异常通过，如 IOExeption、SQLException 等以及用户自定义的 Exception 异常

### 7. String

String 代表的是 Java 中的字符串 ， String 类比较特殊，它整个类都是被 final 修饰的，也就是说，String 不能被任何类继承，任何修改 String 字符串的⽅法都是创建了⼀个新的字符串（保证了线程安全性）。

不可变对象不是真的不可变，可以通过**反射**来对其内部的属性和值进⾏修改，不过⼀般我们不这样做。  

方法`String.intern()`：在 JDK 1.7 及以后调⽤ intern() ⽅法是判断运⾏时常量池中是否有指定的字符串，如果没有的话，就把字符串添加到常量池（JDK 8 之后，字符串常量池在堆中）中，并返回常量池中的对象。  

```java
String a = new String("ab");
String b = new String("ab");
String c = "ab";
String d = "a";
String e = new String("b");
String f = d + e; // + 号相当于是执行 new StringBuilder.append(), 但每次都会new StringBuilder()，所以多次拼接建议自建 StringBuilder
String g = "a" + "b"; // 编译器会优化，会直接被优化为bbbccc，也就是直接创建了一个 bbbccc 对象

System.out.println(a.intern() == b);          //false
System.out.println(a.intern() == b.intern()); //true
System.out.println(a.intern() == c);          //true
System.out.println(a.intern() == f);	      //false
//equals()方法作对比都是true
```

**具体分析：[一篇与众不同的 String、StringBuilder 和 StringBuffer 详解](https://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&mid=2247484794&idx=1&sn=22efd808fa5a9e68cacabd4b6e08fdc3&chksm=e999f068deee797eef9b46b160c06afa4d50e03b3626d1ae1aad05ddc37ec9001c4514264e0f&token=1065926980&lang=zh_CN%23rd)**

- StringBuilder 不加锁
- StringBuffer 线程安全

### 8. 为什么重写 equals 方法必须重写 hashcode 方法  

- 如果在 Java 运⾏期间对同⼀个对象调用 hashCode 方法后，无论调用多少次，都应该返回相同的 hashCode，但是在不同的 Java 程序中，执行 hashCode 方法返回的值可能不⼀致；
- 如果两个对象的 equals 相等，那么 hashCode 必须相同；
- 如果两个对象 equals 不相等，那么 hashCode 也有可能相同，所以需要重写 hashCode 方法，这样也能够提高不同对象的访问速度；
- hashCode 通常是将地址转换为整数来实现的。  

### 9. String s1 = new String("abc") 在内存中创建了几个对象  

⼀个或者两个，String s1 是声明了⼀个 String 类型的 s1 变量，它不是对象。使⽤ new 关键字会在堆中创建⼀个对象，另外⼀个对象是 abc ，它会在常量池中创建，所以⼀共创建了两个对象；如果 abc 在常量池中已经存在的话，那么就会创建⼀个对象。  

