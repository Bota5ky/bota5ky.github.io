#### 设置远程redis

demo工具网站：https://app.redislabs.com

#### 远程登录

```bash
redis-cli -u redis://<username>:<password>@redis-16985.c14.us-east-1-2.ec2.cloud.redislabs.com:16985
```

#### 性能测试

[redis-benchmark](https://redis.io/docs/management/optimization/benchmarks/)

#### 在macOs上查看Redis配置文件

```bash
cat /usr/local/etc/redis.conf
```

默认16个数据库，可以使用`SELECT <index>`切换数据库

```bash
DBSIZE # 查看数据库当前使用的大小
KEYS * # 查看所有的key
FLUSHDB # 清空当前库
FLUSHALL # 清空全部库
MOVE <key> <db> # 移动到指定数据库
EXPIRE <key> <seconds>
TTL <key> # 查看剩余时间 -1表示不会过期 -2表示已过期
TYPE <key> # 查看key类型
```

#### Redis 使用单线程的原因主要有以下几点：

1. 减少锁竞争：Redis 的核心操作是基于内存的，使用单线程可以避免多线程环境下的锁竞争问题，提高性能。由于单线程模型避免了线程切换和上下文切换的开销，可以更高效地利用 CPU。
2. 避免复杂性：多线程编程涉及到线程同步、数据一致性等复杂问题。使用单线程可以避免这些复杂性，使代码更加简单、可靠，减少潜在的错误。
3. 避免资源竞争：Redis 的主要瓶颈是 CPU 和内存带宽，而不是计算能力。使用单线程可以充分利用 CPU 的计算能力，避免了多线程之间因为资源竞争而导致的性能下降。
4. 高效的网络模型：Redis 使用非阻塞的 I/O 多路复用模型，单线程可以处理大量的并发连接。这种模型在处理高并发读写请求时非常高效，避免了线程间切换的开销。

需要注意的是，尽管 Redis 主线程是单线程的，但它通过使用异步 I/O 和多路复用技术实现了非阻塞的网络通信和高并发处理能力。此外，Redis 也提供了一些并发操作的指令，如使用多个 Redis 实例进行数据分片来提高整体性能。

#### String

Store plain string or number

- SET
- GET
- APPEND  # 如果不存在，相当于`SET <key>`
- EXISTS
- INCR
- DECR
- INCRBY
- DECRBY
- GETRANGE <key> <start> <end>  # 包含start和end，end为-1在倒数第1的位置
- SETRANGE <key> <offset> <value>  # 从offset开始替换成value，替换的范围为value的长度
- SETEX <key> <seconds> <value> # 设置key-value和过期时间，不存在则创建
- SETNX # 成功返回1，否则0（在分布式锁中常常会使用）
- MSET
- MGET
- MSETNX  # 有一个存在则全部失败，原子性操作
- GETSET # 先get再set，不存在返回nil，同样会设置新值

#### List

List of strings，实际上是个链表

- LLEN
- LINSERT
- LPUSH # 不存在则创建
- RPUSH # 在尾部添加值
- LPOP
- RPOP
- LINDEX <key> <index> # 找到第index个key的位置，从0开始，末尾从-1开始，越界报错
- LRANGE <key> <start> <stop>
- LREM <key> <count> <value> # 最多移除count个数的value，精确匹配
- LTRIM <key> <start> <stop> # 截取list部分元素
- RPOPLPUSH <key> <newkey>
- LSET <key> <index> <element> # 没有key或者超出原有key的index范围都报错
- LINSERT <key> BEFORE|AFTER <pivot> <element>

#### Hash

Collection of key-value pairs

- HGET
- HSET <key> <field> <value> [field value ...]
- HMGET
- HGETALL
- HMSET
- HDEL
- HLEN
- HEXISTS
- HKEYS
- HVALS

#### Set

Set of strings (each string is unique)

- SADD
- SREM
- SCARD # 获取元素总个数 cardinality 基数
- SDIFF [key ...] # 差集
- SINTER [key ...] # 交集
- SUNION [key ...] # 合集
- SISMEMBER <key> <member>
- SMEMBERS # 显示所有元素
- SPOP # 随机移除元素
- SRANDMEMBER <key> <count> # 随机count个数的获取元素
- SMOVE <source> <destination> <member>

#### Sorted Set

Set of strings in a particular order

- ZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member...]
- ZDIFF
- ZCOUNT
- ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] # -inf +inf ZREVRANGEBYSCORE 逆序

#### Bitmap

Kind of like a collection of booleans

- BITOP
- BITCOUNT
- BITPOS

#### Hyperloglog

Kind of like a collection of booleans

- PFADD
- PFCOUNT
- PFMERGE

#### JSON

Nested JSON structure

- JSON.SET
- JSON.GET
- JSON.DEL

#### Index

Internal data used for searching

- FT.SEARCH
- FT.CREATE
- FT.PROFILE

Documentation for commands: https://redis.io/commands

### 如何降低内存穿透风险？

布隆过滤器（英語：Bloom Filter）是1970年由布隆提出的。 它实际上是**一个很长的二进制向量和一系列随机映射函数**。 布隆过滤器可以用于检索一个元素是否在一个集合中。 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。

### geospatial 地理位置

底层由Zset实现

-  GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...] 地球两极无法直接添加 经度纬度

-  GEODIST # 单位m，km，mi，ft

-  GEOHASH

-  GEOPOS

-  GEORADIUS # 可以限制数量

-  GEORADIUSBYMEMBER

### Hyperloglog

基数，不重复的元素个数，可以接受误差

- PFADD key [element [element ...]]
- PFMERGE
- PFCOUNT

### Bitmap

位存储

- SETBIT key offset value # 最大32位
- BITCOUNT # 统计1的位数个数







### 通过Redis实现一把安全可靠的分布式锁

```sql
SET 'resource_name' 'my_random_value' NX PX 30000
```

`resource_name`：锁的key

`my_random_value`：键值应该为随机数，便于唯一指定地释放，也可以防止超时后误释放别人的锁

`NX`：表示只有当key不存在的时候才能设置成功

`PX`：表示该键值信息会在指定时间之后自动删除

1. 但是很明显，单个Redis实例存在单点故障问题，即一旦Redis发生故障，就会导致整个分布式服务不可用
2. 这个时候你可能会想为该Redis添加Slave节点，以便实现故障转移，但是这里有一个陷阱，虽然添加从节点后，该实例会成为Master，其会进行主从复制，但是这个过程是异步的，也就是说主节点的锁信息还未能同步到从节点便发生故障后，重新选举出来的主节点不一定有锁信息，就会导致其他服务重新获得锁，出现多个服务获得同一把锁的情况
3. 采用Redis的集群部署方案，即有多个Master节点，采用**RedLock算法**

RedLock算法：向N个Redis Master循环发送锁请求信息，使用单实例命令，并设置超时时间

```sql
SET 'LOCK' '1001' NX EX 3000
```

获取成功的条件：

- **半数**以上节点返回Success
- N次加锁请求时间小于**超时时间**

若超时失败，则会向所有Master节点发送释放锁的命令，并随机延迟时间后再去请求获得锁

参考文档：https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html

### 缓存一致性协议

内存使用DRAM的动态随机存储器，缓存使用SRAM的静态随机存储器

MESI: Modified, Exclusive, Shared, Invalid